핀 번호를 다룰 수 있는 이유는 GPIO 핀 제어가 하드웨어에서 **비트 마스크(Bit Masking)**와 **비트 연산(Bitwise Operations)**을 통해 이루어지기 때문입니다. STM32와 같은 마이크로컨트롤러에서 GPIO 핀을 제어하는 방식은 하드웨어 레지스터를 통해 이루어지며, 이 레지스터들은 비트 단위로 동작합니다. 그럼 각 개념을 좀 더 자세히 설명하겠습니다.

1. GPIO (General Purpose Input/Output)
GPIO는 입력이나 출력 기능을 제공하는 핀으로, 다양한 용도로 사용됩니다. STM32 같은 마이크로컨트롤러는 여러 개의 GPIO 핀을 제공하며, 각 핀은 특정 레지스터와 연결됩니다. 이 레지스터를 통해 핀의 상태를 읽거나 설정할 수 있습니다.

2. 비트 마스크(Bit Masking)
GPIO 핀을 설정하거나 확인하는 데 사용되는 주요 원리는 비트 마스크입니다. 비트 마스크는 하나의 비트 필드에서 특정 비트만 선택하거나 수정하는 방법을 의미합니다. GPIO 레지스터는 여러 비트를 가지고 있는데, 각 비트가 각각의 핀에 해당합니다. 예를 들어, GPIOA 포트에는 여러 핀이 있으며, 이들 각각은 GPIOA 레지스터의 각각의 비트로 대응됩니다.

3. 비트 연산 (Bitwise Operations)
비트 연산은 비트 단위로 데이터를 처리하는 연산으로, 주로 AND, OR, XOR, NOT과 같은 연산을 사용합니다. GPIO 핀을 제어할 때, 우리는 비트 연산을 통해 특정 핀을 설정하거나 해제합니다.

4. GPIO 핀 제어 원리
STM32에서 GPIO 핀 제어는 주로 레지스터를 통해 이루어집니다. 예를 들어, GPIOA->ODR (Output Data Register)는 출력 데이터를 관리하며, GPIOA->IDR (Input Data Register)는 입력 데이터를 관리합니다. 각 레지스터는 여러 비트를 가지며, 각 비트가 특정 핀에 대응합니다. 예를 들어, GPIOA->ODR 레지스터에서 0번 비트는 GPIOA의 핀 0, 1번 비트는 GPIOA의 핀 1과 대응됩니다.

5. 핀 번호를 다룰 수 있는 이유
핀 번호는 레지스터의 비트 번호와 연결되어 있습니다. 각 핀에 대해 비트 연산을 사용하여 해당 핀의 상태를 설정하거나 읽을 수 있습니다.

예시
핀을 설정할 때: GPIOA->ODR 레지스터의 0번 비트를 설정하려면, 비트 OR 연산을 사용하여 해당 비트를 1로 만듭니다. 예를 들어, 핀 0을 HIGH로 설정하려면:

c
복사
GPIOA->ODR |= (1 << 0);  // GPIOA의 핀 0을 HIGH로 설정
핀을 해제할 때: GPIOA->ODR 레지스터의 0번 비트를 해제하려면, 비트 AND 연산을 사용하여 해당 비트를 0으로 만듭니다. 예를 들어, 핀 0을 LOW로 설정하려면:

c
복사
GPIOA->ODR &= ~(1 << 0);  // GPIOA의 핀 0을 LOW로 설정
핀 상태 읽기: GPIO 핀의 상태를 읽을 때는 GPIOA->IDR 레지스터를 사용합니다. 예를 들어, 핀 1의 상태를 읽으려면:

c
복사
uint8_t pin_state = (GPIOA->IDR & (1 << 1)) >> 1;  // 핀 1의 상태를 읽어 pin_state에 저장
6. 왜 비트 연산이 중요한가?
비트 연산은 특정 핀만 제어하려는 경우 매우 유용합니다. 예를 들어, GPIOA에 여러 핀이 있는데, 0번 핀만 HIGH로 설정하려면 다른 핀에 영향을 미치지 않도록 AND, OR 연산을 사용하여 특정 비트만 수정할 수 있습니다.

AND 연산: & 연산자를 사용하여 특정 비트를 0으로 만들 수 있습니다.
OR 연산: | 연산자를 사용하여 특정 비트를 1로 설정할 수 있습니다.
NOT 연산: ~ 연산자를 사용하여 비트를 반전시킬 수 있습니다.
7. 핀이 짝수인지 홀수인지 구별하는 방법
핀이 짝수인지 홀수인지 구별하는 것도 비트 연산을 통해 가능합니다. 핀 번호가 짝수인지 홀수인지 확인하려면, 해당 핀 번호가 2로 나누어떨어지는지 확인하는 나머지 연산을 사용할 수 있습니다.

예를 들어, 핀 1이 홀수인지 확인하려면:

c
복사
if (pin_number % 2 != 0) {
    // 홀수 핀
}
비트 연산으로 짝수 핀을 구별하려면 pin_number & 1을 사용할 수 있습니다:

pin_number & 1 == 0: 짝수 핀
pin_number & 1 == 1: 홀수 핀
결론
GPIO 핀 번호는 레지스터의 비트와 대응되며, 비트 연산을 사용하여 각 핀의 상태를 제어합니다. 이 방식 덕분에 핀 번호를 쉽게 다룰 수 있으며, 비트 연산을 통해 특정 핀만 제어하는 것이 가능해집니다. 이를 통해 효율적이고 정밀한 핀 제어가 가능합니다.